{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Project Repository & Configuration",
        "description": "Initialize the Next.js project repository with pnpm 10.14.0, Typescript, ESLint and Tailwind CSS. Establish project structure and environment configuration.",
        "details": "Initialize a new Next.js project using the latest Next.js (v13+) with pnpm 10.14.0. Setup TypeScript with a tsconfig.json, configure ESLint with recommended rules, and integrate Tailwind CSS. Create a basic directory structure (pages, components, lib, etc.). Ensure to commit initial files to version control. Recommended versions: Next.js latest stable, Tailwind CSS 3.x, ESLint 8.x.",
        "testStrategy": "Validate that the project compiles and runs locally. Check that ESLint runs without errors and Tailwind styles load on a sample page.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Configure Database with Prisma and PostgreSQL",
        "description": "Set up Prisma ORM with PostgreSQL, create models for User and File as per the PRD requirements.",
        "details": "Install Prisma CLI and client (latest version, e.g. prisma@4.x). Create a schema.prisma file. Define two models: User (using the base model from better-auth with a unique 'cccd' field, email, etc.) and File to map user to S3 object ID. Configure the connection string in a .env file (use localhost:5432 for development). Run migrations to update the database.",
        "testStrategy": "Test connection to the database with Prisma studio, run a sample query to ensure data insertion and retrieval works without errors. Validate unique constraints on 'cccd'.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Integrate Better-Auth for Authentication",
        "description": "Configure better-auth in Next.js to handle user registration and authentication, ensuring CCCD is integrated as unique identifier.",
        "details": "Follow the Better-Auth integration guide for Next.js. Install better-auth (latest version from the provided link) and follow installation steps. Modify the registration flow to include a 'cccd' input field ensuring its uniqueness. Test basic login and registration functionality. Ensure to secure endpoints against SQL injection by sanitizing inputs.",
        "testStrategy": "Test user registration and login flows through unit tests and manual UI interactions. Validate that the CCCD field behaves as expected and that password reset through email works using a mocked email service.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Student (SV) Registration and Authentication UI",
        "description": "Develop the frontend pages and API routes for student registration and authentication using Better-Auth integration.",
        "details": "Create Next.js pages for student sign-up and login. Use Tailwind CSS for styling a minimal but clean UI. Include input validation (client and server side) for fields: cccd, email, password. Use Next.js API routes to handle authentication logic interfacing with better-auth and Prisma. Include pseudo-code for API route: \n\n// Pseudo-code:\n// POST /api/auth/register:\n//    const { cccd, email, password } = req.body;\n//    Validate inputs;\n//    Call better-auth registration function;\n//    Return success response.",
        "testStrategy": "Manually test the registration process in the browser. Write unit tests for API routes to validate input sanitization, and simulate database insertion.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Develop S3-based File Upload Service Module",
        "description": "Implement a decoupled file upload service that uses AWS S3 SDK as the backend for file storage with a limit of 15MB per file.",
        "details": "Create an abstraction for file storage. For MVP, implement using AWS S3 SDK v3. Handle file size validation (15MB max) on the frontend and backend. Wrap S3 operations in a service layer (e.g. an 'uploadService.ts' file) that can be swapped out in future. Code snippet (pseudo-code):\n\n// if(file.size > 15MB) throw error;\n// s3Client.send(new PutObjectCommand({ Bucket, Key, Body: file }));\n\nEnsure proper error handling and logging. Use environment variables for S3 configuration from .env.",
        "testStrategy": "Write integration tests to upload a file and verify presence in S3 (or a mock S3 service in development). Validate rejection for files >15MB.",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Create Frontend Page for Downloading Sample Form",
        "description": "Develop a minimal frontend page that provides a download button for a sample form to be filled by students.",
        "details": "Create a static Next.js page (e.g. /download) using Tailwind CSS for styling. Implement a simple button that triggers file download for a sample form (e.g. a PDF or DOCX stored locally in the public folder). Use an HTML anchor tag with the download attribute. \n\nExample: <a href='/sample-form.pdf' download>Download Sample Form</a>.",
        "testStrategy": "Verify that clicking the download button retrieves the sample file directly in different browsers. Validate file integrity after download.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Student File Upload UI",
        "description": "Develop a frontend page where students can upload their completed form and integrate it with the backend upload service.",
        "details": "Create a Next.js page (e.g., /upload) with an upload form using Tailwind CSS. Use an <input type='file'> element, limit file selection to <15MB files. On submit, make an API call to the file upload endpoint that uses the upload service from Task 5. Include client-side validation for file type and size.\n<info added on 2025-08-06T04:34:19.376Z>\nImplemented a comprehensive student file upload UI with the following additional features:\n\n• New responsive upload page (/upload) with Tailwind CSS that includes an authentication check and redirects unauthenticated users to login.\n• Enhanced file input supporting both traditional selection and drag-and-drop, along with client-side validations for file size (max 15MB), allowed formats (PDF, DOC, DOCX, JPG, PNG), empty file detection, and MIME type verification.\n• Integrated a three-step backend upload process: obtaining a presigned URL via /api/upload/presigned-url, uploading directly to S3 with XMLHttpRequest (including visual progress tracking via a progress bar and percentage display), and completing the upload by calling /api/upload/complete to save metadata.\n• Improved user experience through file previews with size information, an option to remove files before upload, loading states during authentication, and error handling with user-friendly messages and retry capability.\n• Navigation enhancements include an \"Upload Your Form\" button on the home page, updated download page linking to the upload feature, and authenticated user-aware navigation elements that link to the student dashboard, accompanied by a help section with a link to download a sample form.\n</info added on 2025-08-06T04:34:19.376Z>",
        "testStrategy": "Perform manual testing of file upload functionality; use unit tests for API endpoints handling file uploads, and ensure files beyond the limit are rejected.",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Develop Student Application Status Viewing Page",
        "description": "Create a page that allows students to view the status of their submitted application.",
        "details": "Implement a Next.js page (e.g., /status) that retrieves and displays the current approval status from the backend via an API endpoint. Use Prisma to query the File record associated with the user. Display statuses such as 'Pending', 'Approved', or 'Rejected'. Provide minimal styling with Tailwind CSS.",
        "testStrategy": "Unit test the API route for status retrieval, and perform manual UI tests to verify the correct status is displayed for different scenarios.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Build GV Table View to List Student Submissions",
        "description": "Successfully implemented GV Table View for Student Submissions. The GV (Teacher) dashboard now displays a paginated, searchable table of student submissions with secure file download functionality using presigned URLs.",
        "status": "done",
        "dependencies": [
          3
        ],
        "priority": "medium",
        "details": "Developed a Next.js page (e.g., /gv/dashboard) that now retrieves student records using Prisma from enhanced API endpoints. The dashboard leverages the following features:\n\n• API Endpoints:\n  - /api/admin/submissions: Fetches paginated student submissions with filtering, search (by student name, email, or CCCD), and status filtering (PENDING, APPROVED, REJECTED, ALL).\n  - /api/admin/files/[fileId]/download: Generates presigned download URLs for secure file access.\n\n• Dashboard Features:\n  - Authentication & Authorization with proper teacher role verification\n  - Data Table: Displays columns for name, CCCD, file details, upload date, and status with color-coded status badges\n  - Real-time search and filtering\n  - Server-side pagination with navigation controls\n  - Responsive design ensuring mobile-friendly display with proper overflow handling\n  - User-friendly error handling with loading states and informative error messages\n  - Statistics display to show total submissions and current page information\n  - Empty state handling if no submissions match criteria\n\n• Technical Enhancements:\n  - Implemented in TypeScript with proper Prisma types\n  - Secure file downloads using presigned URLs\n  - Optimized database queries and integration with an existing authentication system\n  - Comprehensive error handling and performance optimizations\n\nThis implementation transforms the initial placeholder GV dashboard into a fully functional administrative interface for managing student submissions.",
        "testStrategy": "Perform smoke tests for pagination, search, and filtering functionalities. Validate file download links to ensure secure presigned URL generation. Manually test the responsive UI across devices and verify proper display of status badges, statistics, and empty states. Use both unit tests and a mocked large dataset to ensure optimal performance and robust error handling.",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Develop GV Detail View for Individual Student Submission",
        "description": "Create a detail view page for GV to see comprehensive information about an individual student's application including file details.",
        "details": "Implement a Next.js dynamic route page (e.g., /gv/student/[id]) that fetches detailed data for a given student using Prisma. Display user details, submission metadata, and provide a download link for the associated file. Ensure input sanitization to protect against injection attacks.",
        "testStrategy": "Manually test the detail view page by passing valid and invalid identifiers. Write unit tests to confirm safe handling and correct data retrieval.",
        "priority": "medium",
        "dependencies": [
          9
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Next.js Dynamic Route for Student Detail View",
            "description": "Create a dynamic route page (e.g., /gv/student/[id]) using Next.js App Router conventions to handle requests for individual student submissions.",
            "dependencies": [],
            "details": "Set up the folder and file structure for the dynamic route using [id] syntax in the app directory. Ensure the route correctly captures the student ID from the URL and passes it to the page component for data fetching and rendering.",
            "status": "done",
            "testStrategy": "Manually navigate to various /gv/student/[id] URLs and verify that the route loads and the ID parameter is accessible in the component."
          },
          {
            "id": 2,
            "title": "Develop API Endpoint for Fetching Detailed Student Submission Data",
            "description": "Create a secure API endpoint that retrieves comprehensive student submission data, including user details, submission metadata, and file information, using Prisma.",
            "dependencies": [
              "10.1"
            ],
            "details": "Implement the API route to accept a student ID, validate it, and query the database for all relevant details. Ensure the endpoint only returns data if the requester is authorized (GV user).",
            "status": "done",
            "testStrategy": "Write unit and integration tests to verify correct data retrieval for valid IDs, proper error handling for invalid or unauthorized requests, and coverage of edge cases."
          },
          {
            "id": 3,
            "title": "Implement Input Validation and Sanitization for Student ID and API Requests",
            "description": "Ensure all incoming parameters, especially the student ID, are properly validated and sanitized to prevent injection attacks and other security vulnerabilities.",
            "dependencies": [
              "10.2"
            ],
            "details": "Apply strict validation rules (e.g., UUID or numeric checks) and sanitize all inputs before using them in database queries or file operations. Use established libraries or custom middleware as appropriate.",
            "status": "done",
            "testStrategy": "Write unit tests to confirm that invalid or malicious input is rejected and does not reach the database layer. Perform manual penetration testing for common injection vectors."
          },
          {
            "id": 4,
            "title": "Integrate File Download Functionality for Submission Files",
            "description": "Provide a secure download link or button on the detail view page that allows authorized GV users to download the associated submission file from storage (e.g., S3).",
            "dependencies": [
              "10.2",
              "10.3"
            ],
            "details": "Implement backend logic to generate secure, time-limited download URLs or proxy file downloads through the API. Ensure only authorized users can access the file and that file paths are not exposed.",
            "status": "done",
            "testStrategy": "Test file downloads with valid and invalid permissions, verify that links expire as expected, and confirm that files cannot be accessed by unauthorized users."
          },
          {
            "id": 5,
            "title": "Build UI Components for GV Detail View with Authorization Controls",
            "description": "Design and implement the frontend components to display user details, submission metadata, and file download options, ensuring only authorized GV users can access the page.",
            "dependencies": [
              "10.1",
              "10.2",
              "10.4"
            ],
            "details": "Use React and Tailwind CSS to create a clear, accessible layout. Integrate authorization checks (e.g., route guards or session validation) to restrict access. Display error messages for unauthorized or invalid access.",
            "status": "done",
            "testStrategy": "Perform manual UI testing for various user roles and states. Write unit tests for component rendering and authorization logic."
          }
        ]
      },
      {
        "id": 11,
        "title": "Implement GV Approval Workflow",
        "description": "Develop the capability for GV to update the approval status of student submissions.",
        "details": "Create an API endpoint (e.g., PUT /api/approval) that allows GV users to update the status of a student's submission. Provide necessary input validations, and update the corresponding record in the File table. Reflect the updated status on the GV detailed view and student status pages. Pseudo-code:\n\n// Validate request and GV user permissions\n// query Prisma to update status field\n// return updated record",
        "testStrategy": "Use API tests to ensure only authorized GV users can update statuses. Verify status changes persist in the database and propagate to the UI.",
        "priority": "medium",
        "dependencies": [
          10
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Develop Load Testing and Optional Sentry Integration",
        "description": "Create load test scripts using Grafana k6 and integrate optional Sentry for error monitoring to ensure system resilience under load.",
        "details": "Write load testing scripts in k6, simulating multiple student and GV interactions (registration, file upload, data fetching). Document thresholds (e.g. concurrent requests). Optionally, integrate Sentry (latest @sentry/node V7+) into both frontend and backend for error monitoring. Provide clear configuration instructions using DSN from Sentry. \n\nExample of k6 script snippet:\n\nimport http from 'k6/http';\nexport default function () {\n  http.get('http://localhost:3000/api/status');\n}\n",
        "testStrategy": "Run k6 scripts to simulate load and observe performance metrics using Grafana dashboards. Validate that Sentry catches and logs errors in testing scenarios.",
        "priority": "low",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Implement Comprehensive Role-Based Authorization Features",
        "description": "Develop and integrate role-based authorization controls that focus on backend API protection with lightweight middleware for quick session validation and efficient role-based checks within API routes and page components.",
        "status": "done",
        "dependencies": [
          3,
          9,
          10
        ],
        "priority": "high",
        "details": "This task involves refactoring the current authorization approach by concentrating on backend-side implementation for improved performance while still ensuring comprehensive security. The updated approach includes: 1) Retaining existing lightweight middleware to perform basic session validations (with sessions populated via Better-Auth from Task 3) for optimal performance; 2) Implementing role-based authorization checks directly within API routes and page components to enforce access restrictions; 3) Creating reusable authorization utility functions for consistent role checking across the application; 4) Adding client-side route guards using React hooks to manage navigation and perform redirection of unauthorized users; 5) Implementing robust error handling mechanisms that return proper 403 responses and clear error messages when access is denied; and 6) Updating navigation menus dynamically to display options based on the user's role.",
        "testStrategy": "Perform unit tests to verify that the lightweight session middleware is functioning properly and that the reusable authorization utilities correctly enforce role-based restrictions in API routes and page components. Use integration tests to simulate both valid and invalid role access attempts and to verify that unauthorized access results in proper 403 error responses and/or redirections. Test the client-side route guards by attempting navigation to restricted pages and confirming that users are redirected with appropriate feedback. Also, validate that dynamic navigation menus correctly reflect the user’s role.",
        "subtasks": [
          {
            "id": 1,
            "title": "Refactor Lightweight Session Middleware",
            "description": "Ensure that the existing lightweight session middleware continues to perform basic session validations using sessions populated via Better-Auth from Task 3. Review and refactor the middleware as needed to maintain optimal performance and reliability.",
            "dependencies": [],
            "details": "Audit the current middleware implementation to confirm it correctly validates sessions. Refactor if necessary to ensure it seamlessly integrates with Better-Auth. Add logging and minimal error handling for session validation failures.\n<info added on 2025-08-06T08:14:08.050Z>\nBackend authorization system implementation is complete. The updated components include robust authorization utilities in /lib/auth-utils.ts, featuring a comprehensive UserRole enum, a verifyAuthorization() function, and custom error classes for enhanced error handling. Custom React hooks in /hooks/useAuthorization.ts (useTeacherAuth() and useStudentAuth()) now manage client-side role-based access with automatic redirects and loading state management. API routes such as /api/admin/submissions and /api/admin/files/[fileId]/download have been updated with centralized role-based checks and proper error responses. Teacher and student dashboards leverage these hooks, eliminating manual role checks. All updates have passed TypeScript validation, resolved ESLint warnings, and optimized performance while maintaining minimal and efficient middleware.\n</info added on 2025-08-06T08:14:08.050Z>",
            "status": "done",
            "testStrategy": "Write unit tests to simulate valid and invalid session scenarios to ensure the middleware correctly validates sessions without overhead."
          },
          {
            "id": 2,
            "title": "Integrate Role-Based Checks in API Routes and Page Components",
            "description": "Embed role-based authorization checks directly within API routes and page components. This step ensures that protected endpoints verify user roles after session validation.",
            "dependencies": [
              "13.1"
            ],
            "details": "Within the API route handlers and page components, insert conditional checks that leverage session data to verify if the user holds the necessary role for the requested resource. Structure the code so that the check runs immediately after the session validation executed by the middleware.",
            "status": "done",
            "testStrategy": "Develop integration tests that simulate requests with various roles to endpoints and verify that access is correctly granted or blocked."
          },
          {
            "id": 3,
            "title": "Develop Reusable Authorization Utility Functions",
            "description": "Extract common role-checking logic into reusable utility functions to promote consistency across the application. These utilities will be invoked by both backend API routes and potentially by frontend components.",
            "dependencies": [
              "13.2"
            ],
            "details": "Create functions such as 'checkUserRole' and 'isAuthorized' that accept session information and desired roles, returning a boolean indicating authorization. Ensure the utilities are modular, easily testable, and can be imported into various parts of the application.",
            "status": "done",
            "testStrategy": "Write unit tests for each utility function to validate that they correctly determine user access based on role. Test with a variety of role combinations and edge cases."
          },
          {
            "id": 4,
            "title": "Implement Client-Side Route Guards with React Hooks",
            "description": "Develop client-side route guards using React custom hooks to enforce role-based access control. These guards will redirect unauthorized users before the page components render.",
            "dependencies": [
              "13.3"
            ],
            "details": "Create a custom React hook (e.g., 'useAuthorization') that checks the user’s role from the session or authentication context and performs redirection if necessary. Integrate this hook within page components so that navigation adjustments occur dynamically.",
            "status": "done",
            "testStrategy": "Perform both unit and integration tests by simulating user navigation. Ensure that unauthorized users are redirected properly and that authorized views render as expected."
          },
          {
            "id": 5,
            "title": "Implement Robust Error Handling and Dynamic Navigation Updates",
            "description": "Enhance the system with comprehensive error handling for unauthorized access and update the dynamic navigation menus to reflect available options based on user roles.",
            "dependencies": [
              "13.2",
              "13.4"
            ],
            "details": "Within API routes, implement robust error handling that returns 403 responses with clear error messages on authorization failure. Update the client-side code to detect these errors and adjust the display of navigation menus dynamically based on the user's role. Ensure that menu options are conditionally rendered using available role data from session validations.",
            "status": "done",
            "testStrategy": "Simulate unauthorized requests and verify that the correct error codes and messages are returned. Use UI tests to validate that navigation menus adapt in real time based on changes to the user’s role."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-08-05T17:49:12.601Z",
      "updated": "2025-08-06T08:54:29.545Z",
      "description": "Tasks for master context"
    }
  }
}